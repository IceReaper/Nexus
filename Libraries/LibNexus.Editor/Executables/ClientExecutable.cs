using System.Security.Cryptography;

namespace LibNexus.Editor.Executables;

public class ClientExecutable
{
	private static readonly byte[] Hash =
	[
		0xA5, 0x97, 0x4E, 0x96, 0x28, 0x89, 0x7F, 0xC1, 0x96, 0x5B, 0x7A, 0x74, 0x0B, 0xCE, 0x68, 0xDF, 0x5B, 0x62, 0x11, 0x75
	];

	public byte[] Bytes { get; }

	public ClientExecutable(string path)
	{
		Bytes = File.ReadAllBytes(path);
	}

	public bool Validate()
	{
		return SHA1.HashData(Bytes).SequenceEqual(Hash);
	}

	public void EnableLoadUnpackedFiles()
	{
		var segments = new Dictionary<int, byte[]>
		{
			//// @formatter:off
			{ 0x000001B6, [0x20] },
			{ 0x001B500B, [0xE9, 0x68, 0x20, 0x7A, 0x00] },
			{ 0x00957078, [0xE8, 0xA3, 0xD3, 0x85, 0xFF, 0x48, 0x8D, 0x8D, 0xB0, 0x01, 0x00, 0x00, 0xFF, 0x15, 0x26, 0x1A, 0x00, 0x00, 0x83, 0xF8, 0xFF, 0x74, 0x04, 0x66, 0x89, 0x5D, 0xA0, 0xE9, 0x78, 0xDF, 0x85, 0xFF] }
			//// @formatter:on
		};

		foreach (var (offset, bytes) in segments)
			Array.Copy(bytes, 0, Bytes, offset, bytes.Length);
	}

	public void EnableBypassLauncher()
	{
		var segments = new Dictionary<int, byte[]>
		{
			//// @formatter:off
			{ 0x0000A2CD, [0x90, 0x90, 0x90, 0x90, 0x90, 0x90] },
			{ 0x0000A2D6, [0x90, 0x90, 0x90, 0x90, 0x90, 0x90] },
			{ 0x0000A2DF, [0x90, 0x90, 0x90, 0x90, 0x90, 0x90] }
			//// @formatter:on
		};

		foreach (var (offset, bytes) in segments)
			Array.Copy(bytes, 0, Bytes, offset, bytes.Length);
	}
}
